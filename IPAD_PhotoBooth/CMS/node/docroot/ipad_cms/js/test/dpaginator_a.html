<html>

<head>
	<title>YUI 3.6 DT Paginator Combo</title>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">

	<link href="ba_example.css" rel="stylesheet" type="text/css" />
    <link href="prettify.css" rel="stylesheet" type="text/css" />

    <style type="text/css">
    /*  CSS for Table A's Paginator View container - A "button" type view  */

        #pagContA .yui3-button {
             font-size:  13px;
             height:     28px;
             width:      auto;
             color:      black;
             text-decoration: none;
             margin-bottom: 10px;
         }

    /*  CSS for Table B's Paginator View container - a default view, just for spacing */

        #pagContB {
            margin-top: 5px;
            margin-bottom: 10px;
        }

    /*  CSS for Table C's Paginator View container - A "bar" type view */
        #pagContC {
            font-size:  12px;
            vertical-align: middle;
            padding:    4px 0;
        }

        #pagContC img.pgControls {
            width:  auto;
            height: 12px;
            padding: 0 4px 0 4px;
            border: none;
            vertical-align: middle;
            cursor: pointer;
        }

        #pagContC img.yui3-pagview-disabled {
            cursor: default;
        }
    </style>
</head>

<body class="yui3-skin-sam" style="visibility: hidden;">

  <h3>YUI 3.6 DataTable-Paginator Demo - Local and Remote Data Examples</h3>

    <div class="ba_intro">
        This example includes three different DataTables with Pagination, all containing different columns and underlying data.
        <br/><br/>The first Table A includes a DT filled with a local JS array as the source, with pagination enabled.
        <br/>Table B includes a DT using remote server-based Pagination, where the data is retrieved via DataSource.IO.
        <br/>Table C includes a DT using a remote REST-based server Pagination, with a complex application requiring Attribute "serverPaginationMap".

    </div>

    <div class="ba_content">

        <h4>Table A : Local "data" via JS Array:</h4>
        <div id="pagContA"></div>
        <div id="tableA"></div>
        <br/>

        <script type="text/x-template" id="tmpl-buttons">
           <button data-pglink="first" class="yui3-button {pageLinkClass}" title="First Page">First</button>
           <button data-pglink="prev" class="yui3-button {pageLinkClass}" title="Prior Page">Prev</button>
           {pageLinks}
           <button data-pglink="next" class="yui3-button {pageLinkClass}" title="Next Page">Next</button>
           <button data-pglink="last" class="yui3-button {pageLinkClass}" title="Last Page">Last</button>
       </script>

        <hr/>

        <h4>Table B : Remote data via DataSource.IO:</h4>
        <div id="pagContB"></div>
        <div id="tableB"></div>
        (A listing of Episodes from a popular US drama TV series ... Breaking Bad)
        <br/><br/>

        <hr/>

        <h4>Table C : Remote data via ModelSync.REST:</h4>
        <div id="tableC"></div>
        <!--  Define the Paginator Bar HTML -->
        <div id="pagContC" class="yui3-pagview-bar"></div>

        <br/>
        The table is initially empty, clicking the "Load" button loads the data and sets up pagination from a RESTful GET request.
        <br/><br/>
        <button id="btnLoadC" class="yui3-button">Load Table C Initial Data</button>
        <br/><br/>

        <!--       SCRIPT template content     -->
        <script type="text/x-template" id="tmpl-bar">
            &nbsp;
            <img src="images/glyph/glyphicons_170_step_backward.png" class="pgControls {pageLinkClass}" data-pglink="first" title="First Page" border="0" />
            <img src="images/glyph/glyphicons_173_backTES.png" class="pgControls {pageLinkClass}" data-pglink="prev" title="Prior Page" border="0" />
            {inputPage} of {totalPages}
            <img src="images/glyph/glyphicons_173_play.png" class="pgControls {pageLinkClass}" data-pglink="next" title="Next Page" border="0" />
            <img src="images/glyph/glyphicons_178_step_forward.png" class="pgControls {pageLinkClass}" data-pglink="last" title="Last Page" border="0" />
            <span style="float:right;margin-right:50px;">Rows per Page: {selectRowsPerPage}</span>
        </script>
    </div>


<script src="http://yui.yahooapis.com/3.11.0/build/yui/yui-min.js"></script>
    <script src="google-code-prettify/prettify.js"></script>
    <script src="dtdata500.js"></script>

<script type="text/javascript">
YUI({
   gallery: 'gallery-2013.01.16-21-05'
}).use( 'datatable-sort', 'datatable-scroll', 'cssfonts', 'cssbutton',  'dataschema-json',
        'datatable-datasource', 'datasource-get',  "datasource-jsonschema",
        'model-sync-rest',  "gallery-datatable-paginator", 'gallery-paginator-view',
        function(Y) {

	    (function (){
	        var html = '<div id="rhtop"><a href="index.html" title="Returns back to index">Return to Main Page<a/> | YUI ' + Y.version + '</div>';
	        Y.one('body').appendChild(html);
	    })();

        Y.one("body").setStyle("visibility","");

//============================================================================================
//    Table A -  Datatable with local data ...
//============================================================================================

    var fmtComma2 = function(o) {
        return Y.DataType.Number.format( o.value, {thousandsSeparator:",", decimalPlaces:2} );
    }

    var fmtComma = function(o) {
        var ndec = ( o.column.ndec ) ? o.column.ndec : 0;
        return Y.DataType.Number.format( o.value, {thousandsSeparator:",", decimalPlaces:ndec} );
    }

    var colsA = [
        { key: "pkey", label: "pkey" },
        { key: "ptxt", label: "Random Text" },
        { key: "pdbl", label: "Random Float", className:'align-right', formatter:fmtComma2 },
        { key: "pint", label: "Random Int", className:'align-right', formatter:fmtComma },
        { key: "pdt",  label: "Random Date/Time" }
    ];

//
//  Create a DT with local data, including a paginator
//
    var dtableA = new Y.DataTable({
        columns:    colsA,
        data:       jsRandom500,
        scrollable: 'y',
        sortable:   true,
        height:     '265px',

        paginator: new Y.PaginatorView({
            model:              new Y.PaginatorModel({itemsPerPage:20}),
            container:          '#pagContA',
            paginatorTemplate:  '#tmpl-buttons',
            maxPageLinks:   6,
            pageLinkFiller: '...',
            linkListOffset: 1,
            pageLinkTemplate:  '<button data-pglink="{page}" class="yui3-button {pageLinkClass}" title="Page No. {page}">{page}</button>'
        }),

        paginationSource: "client"

    }).render('#tableA');

//============================================================================================
//    Table B - Via DataSource.IO
//============================================================================================

    var ds = new Y.DataSource.Get({source:"http://blunderalong.com/data/bb"}); 

    ds.plug( Y.Plugin.DataSourceJSONSchema, {
        schema: {
            resultListLocator: 'Results',
            resultFields: [ 'epno', 'season', 'season_epno', 'title', {key:'odate', parser:"date"} ],
            metaFields: {
                totalItems:     'totalItems',
                itemsPerPage:   'itemsPerPage',
                itemIndexStart: 'itemIndexStart'
            }
        }
    });

    var colsB = [
        { key: "epno", label: "Ep No.", className:'align-center' },
        { key: "season",  label: "Season", className:'align-center' },
        { key: "season_epno",   label: "Season Ep No.", className:'align-center' },
        { key: "title",  label: "Episode Title" },
        { key: "odate",  label: "Original Date", formatter:function(o){
            return Y.DataType.Date.format(o.value,{format:'%D'});
        }, className:'align-center' }
    ];

//
//  Setup a DataTable with DS plugin
//
    var dtableB = new Y.DataTable({
        columns:    colsB,

        paginator: new Y.PaginatorView({
            model:              new Y.PaginatorModel({itemsPerPage:10}),
            container:          '#pagContB',
            pageOptions:        [ 10, 20, 50 ]
        }),

        // Since requestString Template and server response "comply" with the PaginatorModel
        //  properties ... then NO serverPaginatorMap is required ...
        paginationSource:       "remote",
        requestStringTemplate: "?page={page}&itemsPerPage={itemsPerPage}&sortBy={sortBy}"

    });


    dtableB.plug(  Y.Plugin.DataTableDataSource, {datasource: ds });

    dtableB.render('#tableB');

    dtableB.processPageRequest(1);

//============================================================================================
//    Table C - ModelSync.REST with serverPaginationMap
//============================================================================================


//
//  Define a custom Model and ModelList for my music data ...
//
    Music = Y.Base.create('recmusic', Y.Model, [],{},{
        ATTRS:{
            ma_id:{}, ma_mbid:{}, ma_artist:{}, ma_album:{}, ma_year:{}, ma_label:{}
        }
    });

    // In the ModelList class extension, mixin the ModelSync.REST component to handle
    // all server communications.
    // Also;
    //    (1) Override the "url" property with my custom server querystring ... including replacement tokens
    //    (2) Define an attribute "dsSchema" which represents a schema representation to be parsed via DataSchema.
    //    (3) Override the .parse method, to parse my server's response and store the pagination state on success
    //
    MusicList = Y.Base.create('musiclist', Y.ModelList,[],{

        // url setup to handle extra passed-in options for pagination stuff ...
        //url: '/data/musicPage?page={page}&itemsPerPage={itemsPerPage}&sortBy={sortBy}',
      url: 'http://blunderalong.com',
      request:'/data/musicPage?page={page}&itemsPerPage={itemsPerPage}&sortBy={sortBy}',

      // provide a behind-the-scenes sync method instead of using ModelSync.REST,
      //  ... to get around XDR limits between github pages = blunderalong.com
      //
      // HAD TO REALLY HACK THIS UP TO GET IT TO WORK ON Github via Get ....
	  sync: function (action, options, callback) {
	    	var data, lurl;

		    switch (action) {

		      case 'read':

			    var ds = new Y.DataSource.Get( {source:this.url} );   
		  
		        ds.sendRequest({
		          request: Y.Lang.sub(this.request,options),
		          on:{
		            success: function(resp){
		            callback(null,resp);
		            }
		          }
		        });
		        return;
		        
		    }
	  
	      },

        parseJSON: function(resp){
            var parsed   =  resp.data, //Y.JSON.parse(resp),
                results  = [],
                metaflds = {};

            if ( parsed.replyCode === 200 && parsed.Results ) {
                metaflds.indexStart = parsed.itemIndexStart;
                metaflds.pageRecs   = parsed.itemsPerPage;
                metaflds.totalRecords   = parsed.totalItems;
                results = parsed.Results
            }

            return {resp:resp, parsed:parsed, results:results, meta:metaflds};
        },

        parseDataSchema: function(resp){
            var parsed = Y.DataSchema.JSON.apply( this.get('dsSchema'), resp);
            return {resp:resp, parsed:parsed, results:parsed.results, meta:parsed.meta};
        },


        parse: function(resp) {
            var parsedObj = {};

            //if ( this.get('dsSchema') )
            //    parsedObj = this.parseDataSchema(resp.data);
            //else
                parsedObj = this.parseJSON(resp);

        // Define my own event to fire after parsing completes .... in case I want to listen to it somewhere
            this.fire('response',  parsedObj) ;//{resp:resp, parsed:parsed, meta:metadata, results:results});

            return parsedObj.results || [] ;

        }

    },{
        ATTRS:{

            // Define a schema as an attribute so we can parse the response using DataSchemaJSON ...
            dsSchema:   {}
        }
    });


//
//  Instantiate a new ModelList and define some columns for our DataTable
//
    var myMusic = new MusicList({
        model:      Music,

        dsSchema:   {
            resultListLocator: 'Results',
            resultFields: [ 'ma_id', 'ma_mbid', 'ma_artist', 'ma_album', 'ma_year', 'ma_label' ],
            metaFields: {
                currentPage:  'currentPage',
                indexStart:   'indexStart',
                pageRecs:     'pageRecords',
                totalRecords: 'totalRecords'
            }
        }
    });


    var colsC = [
        { key: "ma_artist", label: "Artist" },
        { key: "ma_album",  label: "Release" },
        { key: "ma_year",   label: "Release Year", className:'align-center' },
        { key: "ma_label",  label: "Label" }
    ];

//
//  Setup a DataTable
//
   var dtableC = new Y.DataTable({
        columns:    colsC,
        data:       myMusic,
        scrollable: 'y',
        sortable:   true,
        width:      '880px',
        height:     '265px',
        sortBy:     [ { ma_artist:'asc'  }, { ma_year:'desc'} ],

        paginator: new Y.PaginatorView({
            model:              new Y.PaginatorModel({itemsPerPage:20}),
            container:          '#pagContC',
            paginatorTemplate:  '#tmpl-bar',
            pageOptions:        [ 10, 20, 50 ]
        }),

    //
    // "maps" Paginator.Model attributes to server querystring / returned response ...
    //
        serverPaginationMap: {
            page:           'currentPage',
            totalItems:     'totalRecords',
            itemsPerPage:   { toServer:'numPageRecords', fromServer:'pageRecords' },
            itemIndexStart: 'startIndex'
        },

        paginationSource:   "remote",
        paginatorResize:    true

    });

    dtableC.render('#tableC');

    // Set click handler on button to load the data ....
    Y.one('#btnLoadC').on('click',function(e){
        // load page 1 data ...
        this.processPageRequest(1);
        e.target.set('disabled',true);
    }, dtableC);

    prettyPrint();

});
</script>

</body>
</html>
